// https://github.com/firebase/bolt/blob/master/docs/language.md

/* IMPORTANT NOTES
 * - Access is disallowed by default. If no .write or .read rule is specified at
 *   or above a path, access will be denied.
 * - Child rules can only grant additional privileges to what parent nodes have
 *   already declared. They cannot revoke a read or write privilege.
 * - The .validate rules are only evaluated for non-null values and positive
 *   results do not cascade.
 * - Also perform input validation client-side for best performance and best
 *   user experience when your app is offline.
 */

type User {
  name: String,
  photoUrl: String | Null,
}

isCurrentUser(uid) { auth !== null && auth.uid === uid }

path /users/{userId} is User {
  read() { auth !== null }
  write() { isCurrentUser(userId) }
}

type FCMToken {
  name: String,
  language: String | Null,
}
path /fcm/{userId}/{tokenId} is FCMToken {
  write() { isCurrentUser(userId) }
}

type AccessString extends String {
  validate() {
    (this === "read" || this === "write" || this === "owner") &&
    (
      // It's either a new record, or...
      prior(this) === null ||
      // ...can't change "owner" to anything else, and
      // can't change anything else to "owner".
      ((prior(this) === "owner") === (this === "owner"))
    )
  }
}

type DeckAccess {
  access: AccessString,
}

deckAccessFor(deckId, userId) {
  root.deck_access[deckId][userId].access
}
deckAccess(deckId) {
  deckAccessFor(deckId, auth.uid)
}
deckExisted(deckId) { prior(root.deck_access[deckId]) !== null }
userExists(userId) { root.users[userId] !== null }

path /deck_access/{deckId} {
  read() { prior(deckAccess(deckId)) === "owner" }
  delete() { prior(deckAccess(deckId)) === "owner" }
}
path /deck_access/{deckId}/{sharedWithUserId} is AccessString | DeckAccess {
  read() { isCurrentUser(sharedWithUserId) }

  create() {
    userExists(sharedWithUserId) &&
    (
      deckExisted(deckId) ? (
        // Sharing a deck.
        prior(deckAccess(deckId)) === "owner" &&
        // Make sure access is not owner (there can be only 1 owner!), the
        // actual allowed set of values is handled by AccessString validation.
        deckAccessFor(deckId, sharedWithUserId) !== "owner"
      ) : (
        // Creating a new deck.
        isCurrentUser(sharedWithUserId) &&
        deckAccess(deckId) === "owner"
      )
    )
  }
  update() { prior(deckAccess(deckId)) === "owner" }
  delete() {
    (
      isCurrentUser(sharedWithUserId) ||
      prior(deckAccess(deckId)) === "owner"
    ) &&
    (
      // Not deleting ownership access...
      prior(deckAccessFor(deckId, sharedWithUserId)) !== "owner" ||
      // ...unless the deck is also gone.
      deckAccessFor(deckId, sharedWithUserId) === null
    )
  }
}

type TransitionToTrueOnlyBoolean extends Boolean {
  validate() { !prior(this) || this }
}

type Deck {
  name: String,
  deckType: String,
  category: String | Null,
  accepted: TransitionToTrueOnlyBoolean,
  lastSyncAt: Number,
  markdown: Boolean,
}

path /decks/{userId} {
  read() { isCurrentUser(userId) }
}
path /decks/{userId}/{deckId} is Deck {
  create() {
    deckAccess(deckId) === "owner" &&
    userExists(userId) &&
    (isCurrentUser(userId) === this.accepted)
  }

  update() { isCurrentUser(userId) }

  delete() {
    // Receiver can delete deck from themselves
    isCurrentUser(userId) ||
    // Owner can un-share or delete deck
    prior(deckAccess(deckId)) === "owner"
  }
}

type CreatedAtTimestamp extends Number {
  validate() {
    (prior(this) === null && this === now) ||
    this === prior(this)
  }
}

type Card {
  front: String,
  back: String,
  // TODO(dotdoom): CreatedAtTimestamp. Firebase Offline "lies" to the
  //                application, replacing ServerValue.TIMESTAMP with
  //                phone's time when fetched (although it saves it
  //                to the server correctly when online). Have to do our
  //                own object mapping to avoid resetting this value.
  createdAt: Number | Null,
}

path /cards/{deckId} {
  read() { deckAccess(deckId) != null }
  write() {
    prior(deckAccess(deckId)) === "write" ||
    prior(deckAccess(deckId)) === "owner"
  }
}
path /cards/{deckId}/{cardId} is Card;

type CardLevel extends String {
  validate() { this.test(/^L[0-9]$/) }
}

type CardReply extends String {
  validate() { this === "Y" || this === "N" }
}

type View {
  levelBefore: CardLevel,
  reply: CardReply,
  timestamp: Number,
}

path /views/{userId} {
  read() { isCurrentUser(userId) }
  write() { isCurrentUser(userId) }
}
path /views/{userId}/{deckId}/{cardId}/{viewId} is View {
}

type ScheduledCard {
  level: CardLevel,
  repeatAt: Number,
}

path /learning/{userId} {
  read() { isCurrentUser(userId) }
  write() { isCurrentUser(userId) }
}
path /learning/{userId}/{deckId}/{cardId} is ScheduledCard {
  index() { "repeatAt" }
}

// Data recovery (see MultiWrite.java).
path /trash {
  write() { true }
}
